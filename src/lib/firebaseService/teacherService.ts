import {
  Firestore,
  doc,
  setDoc,
  getDoc,
  updateDoc,
  deleteDoc,
  collection,
  addDoc, // Using addDoc to let Firestore generate 'id' for teachers collection
  getDocs,
  query,
  where,
  serverTimestamp,
  Timestamp,
  WriteBatch, // For batch operations if needed, though we'll coordinate in components
  orderBy,
} from 'firebase/firestore';
import type { Teacher } from '@/types'; // User type not directly needed here but good for context
import { db } from '@/lib/firebase';

// Re-export Teacher type for convenience
export type { Teacher };

/**
 * Creates a new teacher profile in Firestore.
 * The 'id' for the teacher profile will be auto-generated by Firestore.
 * @param db Firestore instance.
 * @param teacherData Object containing userId and other teacher-specific fields.
 *                    It should not include 'id', 'createdAt', or 'updatedAt'.
 * @returns Promise<string> The ID of the newly created teacher profile.
 */
export const createTeacherProfile = async (
  db: Firestore,
  // Explicitly define the expected type for teacherData, excluding auto-generated fields
  teacherData: Pick<Teacher, 'userId' | 'subjects' | 'groups' | 'specialization' | 'experience' | 'education'>
): Promise<string> => {
  const dataWithTimestamps: Omit<Teacher, 'id'> = {
    ...teacherData,
    createdAt: serverTimestamp() as Timestamp,
    updatedAt: serverTimestamp() as Timestamp,
  };
  const docRef = await addDoc(collection(db, 'teachers'), dataWithTimestamps);
  return docRef.id;
};

/**
 * Fetches a specific teacher profile from Firestore by its document ID.
 * @param db Firestore instance.
 * @param teacherProfileId The document ID of the teacher profile.
 * @returns Promise<Teacher | null> The teacher profile or null if not found.
 */
export const getTeacherProfile = async (
  db: Firestore,
  teacherProfileId: string
): Promise<Teacher | null> => {
  const teacherRef = doc(db, 'teachers', teacherProfileId);
  const docSnap = await getDoc(teacherRef);
  if (docSnap.exists()) {
    return { id: docSnap.id, ...docSnap.data() } as Teacher;
  }
  return null;
};

/**
 * Fetches a teacher profile from Firestore based on the userId.
 * Assumes there's at most one teacher profile per userId.
 * @param db Firestore instance.
 * @param userId The UID of the user associated with the teacher profile.
 * @returns Promise<Teacher | null> The teacher profile or null if not found.
 */
export const getTeacherProfileByUserId = async (
  db: Firestore,
  userId: string
): Promise<Teacher | null> => {
  const teachersCollection = collection(db, 'teachers');
  const q = query(teachersCollection, where('userId', '==', userId));
  const querySnapshot = await getDocs(q);

  if (!querySnapshot.empty) {
    // Assuming only one profile per userId
    const docSnap = querySnapshot.docs[0];
    return { id: docSnap.id, ...docSnap.data() } as Teacher;
  }
  return null;
};

/**
 * Updates an existing teacher profile in Firestore.
 * @param db Firestore instance.
 * @param teacherProfileId The document ID of the teacher profile to update.
 * @param updates Partial data of Teacher to update. Excludes 'id', 'userId', 'createdAt'.
 * @returns Promise<void>
 */
export const updateTeacherProfile = async (
  db: Firestore,
  teacherProfileId: string,
  updates: Partial<Pick<Teacher, 'subjects' | 'groups' | 'specialization' | 'experience' | 'education'>>
): Promise<void> => {
  const teacherRef = doc(db, 'teachers', teacherProfileId);
  const dataWithTimestamp = {
    ...updates,
    updatedAt: serverTimestamp() as Timestamp,
  };
  return updateDoc(teacherRef, dataWithTimestamp);
};

/**
 * Deletes a teacher profile from Firestore.
 * Note: This function does NOT update the corresponding User document's teacherId.
 * That logic should be handled by the calling function, potentially using a batch write.
 * @param db Firestore instance.
 * @param teacherProfileId The document ID of the teacher profile to delete.
 * @returns Promise<void>
 */
export const deleteTeacherProfileInService = async ( // Renamed to avoid conflict with actual delete operation logic
  db: Firestore,
  teacherProfileId: string
): Promise<void> => {
  const teacherRef = doc(db, 'teachers', teacherProfileId);
  return deleteDoc(teacherRef);
};

/**
 * Fetches all teacher profiles from Firestore.
 * @param db Firestore instance.
 * @returns Promise<Teacher[]> An array of teacher profiles.
 */
export const getAllTeachers = async (db: Firestore): Promise<Teacher[]> => {
  const teachersCollection = collection(db, 'teachers');
  const q = query(teachersCollection, orderBy('createdAt', 'desc')); // Optional: order by creation
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(docSnap => ({
    id: docSnap.id,
    ...docSnap.data(),
  } as Teacher));
};

export const getTeachersByGroup = async (groupId: string): Promise<Teacher[]> => {
  const q = query(
    collection(db, 'users'),
    where('role', '==', 'teacher'),
    where('groups', 'array-contains', groupId)
  );
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({
    uid: doc.id,
    ...doc.data(),
  } as Teacher));
};

export const assignTeacherToGroup = async (
  teacherId: string,
  groupId: string
): Promise<void> => {
  const teacherRef = doc(db, 'users', teacherId);
  const teacherDoc = await getDoc(teacherRef);
  
  if (!teacherDoc.exists()) {
    throw new Error('Teacher not found');
  }
  
  const teacherData = teacherDoc.data();
  const groups = teacherData.groups || [];
  
  if (!groups.includes(groupId)) {
    await updateDoc(teacherRef, {
      groups: [...groups, groupId],
    });
  }
};

export const removeTeacherFromGroup = async (
  teacherId: string,
  groupId: string
): Promise<void> => {
  const teacherRef = doc(db, 'users', teacherId);
  const teacherDoc = await getDoc(teacherRef);
  
  if (!teacherDoc.exists()) {
    throw new Error('Teacher not found');
  }
  
  const teacherData = teacherDoc.data();
  const groups = teacherData.groups || [];
  
  if (groups.includes(groupId)) {
    await updateDoc(teacherRef, {
      groups: groups.filter((id: string) => id !== groupId),
    });
  }
};
